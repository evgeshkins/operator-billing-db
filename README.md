# Реализация подсистемы биллинга сотового оператора
# Задача: реализовать подсистему биллинга сотового оператора. Реализовывать надо только часть на стороне БД.
Клиентами этой БД будут: АРМ менеджера, телефонная станция, мобильное приложение клиента. <br>
Клиенты будут подключаться к БД напрямую, но надо реализовать подход, чтобы клиенты не имели доступа до таблиц БД. Все взаимодействие будет выполняться через представления и функции/хранимые процедуры. <br>
# Клиенты будут выполнять следующие функции:
## АРМ менеджера:
- работа со справочником тарифов; <br>
- создание абонента; <br>
- пополнение баланса абонента. <br>
## Телефонная станция
- запрос доступного к-ва минут; <br>
- списание за совершенный звонок. <br>
## Мобильное приложение
- просмотр истории списаний/зачислений денежных средств; <br>
- перевод денег другому абоненту. <br>
 <br>
 <br>

# Отзыв по выполненному заданию:
Добрый день! <br>
Просмотрел решение, и в целом могу сказать что "оно может работать". <br>
Но какие могу написать замечания по нему, к которым нужно прислушаться и подумать, как сделать лучше <br>
Организация представлений. Считается достаточно плохой практикой создавать представления через `select *`. В разных СУБД реализуется это по разному, но в PostgreSQL он "автоматом" создаёт представление с полным перечислением полей. НО! Если сделать в таком виде, как указано - то при добавлении нового поля в таблицы в представлении "автоматически" они не появятся. <br>
Второе замечание по представлениям - это добавление сортировки в сам код представления. Почему это считается "плохим" решением - потому что данная сортировка будет работать "ВСЕГДА". Даже если будет выборка 1 строки, то чтобы её выдать СУБД придётся сделать выборку ВСЕЙ таблицы, отсортировать данные и выдать эту одну строку. <br>
Третье замечание связанное с представлением - это производить операции создания/изменения/удаления данных через представления. Представления в первую очередь нужны для "представления" данных. Да, через них есть возможность производить операции управления данными, но это чаще всего приводит к путаницам. Да и если все "изменения" данных производятся через функционал в БД - то почему нельзя сразу с таблицами там работать? <br>
Дальше замечания по триггерам. В целом, реализация бизнес-логики на триггерах это не лучшее решение. Это чаще всего является "скрытым" решением, что усложняет разбор бизнес-логики и утяжеляет её поддержание. Стоит использовать триггерную логику как можно реже, иначе можно легко запутаться <br>
В рамках триггерной функции call_insert_trigger_fnc идёт 8 читающих и 2 пишущих обращения к представлению st_view. В худшем случае это будут как раз 8 чтений с диска, что выглядит достаточно накладным. Так же данный вариант реализации СИЛЬНО ухудшает читаемость кода, и дальнейшую его модификацию. Более хорошим вариантом тут будет один раз в начале функции вычитать требуемые данные из таблицы (именно таблицы а не представления) и уже дальше их использовать <br>
Поговорим про процедуру delete_tariff. В рамках неё нет проверок и адекватных обработок ситуации если "уже" есть клиент с удаляемым тарифов. В этом случае менеджер получит необработанное исключение, с непонятным для него "нарушением целостности по внешним ключам". Да и в целом, удаление данных в справочниках - это крайне редкая ситуация, которая может приводить к плачевным последствиям. Чаще в справочники вводят признак "заблокированности", и через него производят управление, чем удаляют. <br>
Поговорим про процедуру subscriber_create. В целом данная процедура подразумевает "создание" клиента. Но в неё нет никаких проверок на то, что подобный клиент или номер телефона уже существует. Как следствие, такое поведение может привести к дублированию данных, не взирая на попытки нормализации. Так же, использования запроса `SELECT MAX (sub_id) FROM subscriber_view` для получения "последнего созданного" клиента не гарантирует что мы получим того клиента, которого мы тут "создали". Это работало бы в случае "однопользовательской" системы. Стоит посмотреть в сторону получения информации о вставленных данных. В рамках PostgreSQL в синтаксисе вставки данных подразумевается ключевое слово `returning`, которое позволяет получить указанные поля после вставки. <br>
Ну и как следствие предыдущего замечания, функция `select_minute_quantity` не понятно что будет выдавать. И в целом она может вообще "сломаться", потому что внутренний запрос может вернуть "несколько" строк, что не подразумевает синтаксис `return` в данном случае <br>
Поговорим про процедуру money_transfer. В текущей реализации она может приводить к появлению deadlock, в случае если 2 клиента одновременно захотят перевести средства друг другу. <br>
<br>
<br>
После выполнения данного задания был допущен к собеседованию на позицию практиканта, однако отказался, т.к. офис находится в другом городе.<br>
Задание было выполнено в августе 2023 года, на github выложил только сейчас.